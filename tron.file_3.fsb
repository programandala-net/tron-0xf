\ Tron
\ A game written in ZX Spectrum's Abersoft Forth.

\ tron.file_3.fsb
\ This file is the 4th part of the source.
\ It contains the basic words to manage the keyboard.

\ Copyright (C) 1985,2009,2015 Marcos Cruz (programandala.net)
\ Licencia/Permesilo/License: GPL 3

( Load )

2 10 THRU
RUNT \ load the next part of the source

( Keyboard: Y/N )

: AKEY  ( -- c )
  \ Wait for a key press and return its code.  This is an
  \ alternative to Abersoft Forth's 'KEY', because it always
  \ shows the flashing cursor, even if the current attributes
  \ are changed.
  BEGIN  INKEY DUP 255 =  WHILE  DROP  REPEAT  ;

: PAUSE  ( -- )
  \ Wait for a key press.
  "PRESS-ANY-KEY" <TYPE> AKEY  ;

: UPPER  ( c -- c' )
  \ Convert a char in the range a-z to uppercase
  \ (Warning: no check!, chars other than a-z get corrupted).
  223 AND  ;

  \ Is the given char a valid answer for a Y/N question?
: Y/N?  ( c -- flag )  UPPER DUP 'Y' = SWAP 'N' = OR  ;

  \ Wait for a valid key press for a Y/N question
  \ and return its code.
: Y/N  ( -- c )  BEGIN  AKEY DUP Y/N? 0= WHILE DROP REPEAT  ;

  \ Wait for a valid key press for a Y/N question
  \ and return a flag: Was it "N" or "n"?
: NO?  ( -- flag )  Y/N UPPER 'N' =  ;

( Keyboard: KEYS table )

40 CONSTANT #KEYS  \ number of keys of ZX Spectrum
 4 CONSTANT /KEY  \ bytes per key in the table

 0 VARIABLE KEYS CELL NEGATE ALLOT

  \ Every element of the `KEYS` table occupies 6 bytes and
  \ has the following structure:

  \ +0 = port of the keyboard row (2 bytes)
  \ +2 = bitmask of the key (2 bytes, but only the LSB is used)
  \ +4 = key name (2 bytes), wich can be an ASCII letter
  \      or a cfa that returns a string when executed.
  
  \ Elements are identified by their absolute address in the
  \ table.

( Keyboard: KEYS table, rows 1-5 Q-T A-G )

01 F7FE , , ,  \ K-1
02 F7FE , , ,  \ K-2
04 F7FE , , ,  \ K-3
08 F7FE , , ,  \ K-4
10 F7FE , , ,  \ K-5

01 FBFE , , ,  \ K-Q
02 FBFE , , ,  \ K-W
04 FBFE , , ,  \ K-E
08 FBFE , , ,  \ K-R
10 FBFE , , ,  \ K-T

01 FDFE , , ,  \ K-A
02 FDFE , , ,  \ K-S
04 FDFE , , ,  \ K-D
08 FDFE , , ,  \ K-F
10 FDFE , , ,  \ K-G

( Keyboard: KEYS table, rows CS-V 0-9 P-Y )

01 FEFE , , ,  \ K-CS
02 FEFE , , ,  \ K-Z
04 FEFE , , ,  \ K-X
08 FEFE , , ,  \ K-C
10 FEFE , , ,  \ K-V

01 EFFE , , ,  \ K-0
02 EFFE , , ,  \ K-9
04 EFFE , , ,  \ K-8
08 EFFE , , ,  \ K-7
10 EFFE , , ,  \ K-6

01 DFFE , , ,  \ K-P
02 DFFE , , ,  \ K-O
04 DFFE , , ,  \ K-I
08 DFFE , , ,  \ K-U
10 DFFE , , ,  \ K-Y

( Keyboard: KEYS table, rows EN-H SP-B )

01 BFFE , , ,  \ K-EN
02 BFFE , , ,  \ K-L
04 BFFE , , ,  \ K-K
08 BFFE , , ,  \ K-J
10 BFFE , , ,  \ K-H

01 7FFE , , ,  \ K-SP
02 7FFE , , ,  \ K-SS
04 7FFE , , ,  \ K-M
08 7FFE , , ,  \ K-N
10 7FFE , , ,  \ K-B

( Keyboard: PRESSED? KEY-NAME )

: PRESSED?  ( a -- flag )
  \ Is a key pressed?
  \ a = key address in the `KEYS` table
  2@ INP AND 0=  ;

: C>S  ( c -- ca len )
  \ Convert a character to a string.
  PAD 2! PAD 1  ;

: KEY-NAME  ( a -- ca len )
  \ Convert a key identifier to its key name.
  \ a = key address in the `KEYS` table
  4 + @ DUP 255 > IF  EXECUTE  ELSE  C>S  THEN  ;

: PRESSED  ( -- a )
  \ Wait for a key to be pressed an return its identifier.
  \ a = key address in the `KEYS` table
  0 BEGIN
    [ KEYS #KEYS /KEY * BOUNDS SWAP ] LITERAL LITERAL DO
      I PRESSED? IF  DROP I LEAVE  THEN
    /KEY +LOOP
  UNTIL  ;

  \ vim: filetype=abersoftforth:fileencoding=utf-8
