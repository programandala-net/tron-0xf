\ Tron 0xF
\ A game written in ZX Spectrum's Abersoft Forth.

\ tron.file_3.fsb
\ This file is the 4th part of the source.
\ It contains the basic words to manage the keyboard.

\ Copyright (C) 1985,2009,2015 Marcos Cruz (programandala.net)
\ Licencia/Permesilo/License: GPL 3

\ http://programandala.net/es.programa.tron.html

.( Loading Tron: keyboard )

2 10 THRU
RUNT \ load the next part of the source

( Y/N )

: PAUSE  ( -- )
  \ Wait for a key press.
  PRESS-ANY-KEY$ <TYPE> AKEY  ;

: UPPER  ( c -- c' )
  \ Convert a char in the range a-z to uppercase
  \ (Warning: no check!, chars other than a-z get corrupted).
  223 AND  ;

  \ Is the given char a valid answer for a Y/N question?
: Y/N?  ( c -- flag )  UPPER DUP 'Y' = SWAP 'N' = OR  ;

  \ Wait for a valid key press for a Y/N question
  \ and return its code.
: Y/N  ( -- c )  BEGIN  AKEY DUP Y/N? 0= WHILE DROP REPEAT  ;

  \ Wait for a valid key press for a Y/N question
  \ and return a flag: Was it "N" or "n"?
: NO?  ( -- flag )  Y/N UPPER 'N' =  ;

( Player keys )

4 CONSTANT KEYS/PLAYER  \ keys defined per player

  \ Every player has a table with her defined keys, in the
  \ following order: up, down, left, right.  They are the key
  \ addresses in the `KEYS` table.

  \ The constants hold the specific addresses in the table
  \ and thus they work like variables.

KEYS/PLAYER CELLS BUFFER: KEYS1
  KEYS1           CONSTANT UP-K1
  KEYS1 CELL+     CONSTANT DOWN-K1
  KEYS1 2 CELLS + CONSTANT LEFT-K1
  KEYS1 3 CELLS + CONSTANT RIGHT-K1

KEYS/PLAYER CELLS BUFFER: KEYS2
  KEYS2           CONSTANT UP-K2
  KEYS2 CELL+     CONSTANT DOWN-K2
  KEYS2 2 CELLS + CONSTANT LEFT-K2
  KEYS2 3 CELLS + CONSTANT RIGHT-K2

( KEYS table )

40 CONSTANT #KEYS  \ number of keys of ZX Spectrum
 6 CONSTANT /KEY  \ bytes per key in the table

: KEY" ( "ccc<quote>" -- n )
  \ Parse a key name and leave a number ...
  \ XXX TODO
  [CHAR] " PARSE-TEXT
  ;

HERE: KEYS

  \ Every element of the `KEYS` table 
  \ has the following structure:

  \ +0 = port of the keyboard row (2 bytes)
  \ +2 = bitmask of the key (2 bytes, but only the LSB is used)
  \ +4 = key name (2 bytes), that can be one the following:
  \        - ASCII letter
  \        - cfa of a word that returns a string
  
  \ Elements are identified by their absolute address in the
  \ table.

HEX

( KEYS table, rows 1-5 Q-T A-G )

CHAR 1 01 F7FE , , ,
CHAR 2 02 F7FE , , ,
CHAR 3 04 F7FE , , ,
CHAR 4 08 F7FE , , ,  HERE LEFT-K1 ! \ the "5" key
CHAR 5 10 F7FE , , , 

CHAR Q 01 FBFE , , ,  HERE UP-K2 !    \ XXX TMP
CHAR W 02 FBFE , , ,  HERE DOWN-K2 !  \ XXX TMP
CHAR E 04 FBFE , , ,  HERE LEFT-K2 !  \ XXX TMP
CHAR R 08 FBFE , , ,  HERE RIGHT-K2 ! \ XXX TMP
CHAR T 10 FBFE , , ,

CHAR A 01 FDFE , , ,
CHAR S 02 FDFE , , ,
CHAR D 04 FDFE , , ,
CHAR F 08 FDFE , , ,
CHAR G 10 FDFE , , ,

( KEYS table, rows CS-V 0-9 P-Y )

' CAPS-SHIFT$ CFA 01 FEFE , , ,
CHAR Z 02 FEFE , , ,
CHAR X 04 FEFE , , ,
CHAR C 08 FEFE , , ,
CHAR V 10 FEFE , , ,

CHAR 0 01 EFFE , , ,
CHAR 9 02 EFFE , , ,  HERE RIGHT-K1 !  \ the "8" key
CHAR 8 04 EFFE , , ,  HERE UP-K1 !     \ the "7" key
CHAR 7 08 EFFE , , ,  HERE DOWN-K1 !   \ the "6" key
CHAR 6 10 EFFE , , ,

CHAR P 01 DFFE , , ,
CHAR O 02 DFFE , , ,
CHAR I 04 DFFE , , ,
CHAR U 08 DFFE , , ,
CHAR Y 10 DFFE , , ,

( KEYS table, rows EN-H SP-B )

' ENTER$ CFA 01 BFFE , , ,
CHAR L 02 BFFE , , ,
CHAR K 04 BFFE , , ,
CHAR J 08 BFFE , , ,
CHAR H 10 BFFE , , ,

' SPACE$ CFA 01 7FFE , , ,
' SYMBOL-SHIFT$ CFA 02 7FFE , , ,
CHAR M 04 7FFE , , ,
CHAR N 08 7FFE , , ,
CHAR B 10 7FFE , , ,

DECIMAL

( K#>A KEY-NAME )

: K#>A  ( n -- a )
  \ Convert a key number to its address in `KEYS`.
  /KEY * KEYS +  ;

: C>S  ( c -- ca len )
  \ Convert a character to a string.
  PAD C! PAD 1  ;

: 2C>S  ( 16bit -- ca len )
  \ Convert two characters to a string.
  \ XXX TODO -- test
  [ HEX ] DUP 00FF AND PAD C!
              FF00 AND PAD 1+ C!  PAD 2 [ DECIMAL ]  ;
  \ XXX TODO -- this alternative can work:
  \ PAD ! PAD 2  ;
  

: KEY-NAME  ( a -- ca len )
  \ Convert a key identifier to its key name.
  \ a = key address in the `KEYS` table
  \ XXX TODO change the long names and the table format:
  \ use two chars (En for Enter, SS for Symbol Shift,
  \ CS for Caps Shift, Sp for Space) instead of strings.
  4 + @ DUP 256 U< IF  C>S  ELSE  EXECUTE  THEN  ;

( PRESSED? PRESSED )

: PRESSED?  ( a -- flag )
  \ Is a key pressed?
  \ a = key address in the `KEYS` table
  2@ INP AND 0=  ;

: (PRESSED)  ( -- a true | false )
  \ Check all keys.
  \ a = key address in the `KEYS` table
  FALSE  \ default
  [ KEYS #KEYS /KEY * BOUNDS SWAP ] LITERAL LITERAL DO
    I PRESSED? IF  DROP I TRUE LEAVE  THEN
  /KEY +LOOP  ;

: PRESSED  ( -- a )
  \ Check all keys forever until one of them is pressed
  \ and return its identifier.
  \ a = key address in the `KEYS` table
  BEGIN  (PRESSED) ?EXIT  AGAIN  ;

  \ vim: filetype=abersoftforth:fileencoding=utf-8
