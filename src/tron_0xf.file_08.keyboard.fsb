\ tron_0xf.file_08.keyboard.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 1985,2009,2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

.( Tron 0xF: keyboard )

2 10 THRU

( Y/N input )

: PRESS-ANY-KEY  ( -- )
  \ Wait for a key press.
  CR PRESS-ANY-KEY$ 23 |LINETYPE|
  500 MS  AKEY DROP KEY-SOUND  ;

: MORE  ( -- )
  PRESS-ANY-KEY WIPE-CONTENTS  ;

: Y/N?  ( c -- f )
  \ Is the given char a valid answer for a Y/N question?
  UPPERC DUP 'Y' = SWAP 'N' = OR  ;

: Y/N  ( -- c )
  \ Wait for a valid key press for a Y/N question
  \ and return its code.
  BEGIN  AKEY DUP Y/N? 0=  WHILE  DROP  REPEAT  KEY-SOUND  ;

: NO?  ( -- f )
  \ Wait for a valid key press for a Y/N question
  \ and return a flag: Was it "N" or "n"?
  Y/N UPPERC 'N' =  ;

( KEYS table )

40 CONSTANT #KEYS   \ number of keys of ZX Spectrum
 6 CONSTANT /KEY    \ bytes per key in the table

: SPECIAL-KEY-NAME  ( c1 c2 -- n )
  \ Convert two characters to a 16-bit number.
  256 * +  ;

HERE: KEYS

  \ Every element of the `KEYS` table 
  \ has the following structure:

  \ +0 = port of the keyboard row (2 bytes)
  \ +2 = bitmask of the key (2 bytes, but only the LSB is used)
  \ +4 = key name (2 bytes): one letter (the second byte is
  \      zero and will be ignored) or two letters.
  
  \ Keys are identified by their absolute address in the table.
  \
  \ The players' default keys are set while the table is being
  \ compiled, by storing the dictionary pointer into a player
  \ variable.
  \
  \ The default keys of players 1 and 3 correspond to the
  \ Sinclair joysticks (keys 1-4 and 6-9); the default keys of
  \ player 2 are suitable for the Dvorak keyboard layout (keys
  \ K, X, B, M).

HEX

( KEYS table, rows 1-5 Q-T )

                      HERE LEFT-K0 !   \ "1"
CHAR 1 01 F7FE , , ,  HERE RIGHT-K0 !  \ "2"
CHAR 2 02 F7FE , , ,  HERE UP-K0 !     \ "3"
CHAR 3 04 F7FE , , ,  HERE DOWN-K0 !   \ "4"
CHAR 4 08 F7FE , , ,
CHAR 5 10 F7FE , , , 

CHAR Q 01 FBFE , , ,
CHAR W 02 FBFE , , ,
CHAR E 04 FBFE , , ,
CHAR R 08 FBFE , , ,
CHAR T 10 FBFE , , ,

( KEYS table, rows A-G CS-V 0-6 )

CHAR A 01 FDFE , , ,
CHAR S 02 FDFE , , ,
CHAR D 04 FDFE , , ,
CHAR F 08 FDFE , , ,
CHAR G 10 FDFE , , ,

CHAR C CHAR S SPECIAL-KEY-NAME 01 FEFE , , ,  \ Caps Shift
CHAR Z 02 FEFE , , ,  HERE RIGHT-K2 ! \ "X"
CHAR X 04 FEFE , , ,
CHAR C 08 FEFE , , ,
CHAR V 10 FEFE , , ,

CHAR 0 01 EFFE , , ,  HERE DOWN-K1 !  \ "9"
CHAR 9 02 EFFE , , ,  HERE UP-K1 !    \ "8"
CHAR 8 04 EFFE , , ,  HERE RIGHT-K1 ! \ "7"
CHAR 7 08 EFFE , , ,  HERE LEFT-K1 !  \ "6"
CHAR 6 10 EFFE , , ,

( KEYS table, rows P-Y En-H )

CHAR P 01 DFFE , , ,
CHAR O 02 DFFE , , ,
CHAR I 04 DFFE , , ,
CHAR U 08 DFFE , , ,
CHAR Y 10 DFFE , , ,

CHAR E CHAR n SPECIAL-KEY-NAME 01 BFFE , , ,  \ Enter
CHAR L 02 BFFE , , ,  HERE LEFT-K2 !  \ "K"
CHAR K 04 BFFE , , ,
CHAR J 08 BFFE , , ,
CHAR H 10 BFFE , , ,

( KEYS table, row Sp-B )

CHAR S CHAR p SPECIAL-KEY-NAME 01 7FFE , , ,  \ Space
CHAR S CHAR S SPECIAL-KEY-NAME 02 7FFE , , ,  \ Symbol Shift
                      HERE DOWN-K2 !  \ "M"
CHAR M 04 7FFE , , ,
CHAR N 08 7FFE , , ,  HERE UP-K2 !    \ "B"
CHAR B 10 7FFE , , ,

DECIMAL

( K#>A KEY-NAME )

: K#>A  ( n -- a )
  \ Convert a key number to its address in `KEYS`.
  /KEY * KEYS +  ;

: C>S  ( c -- ca len )
  \ Convert a character to a string.
  PAD C! PAD 1  ;

: 2C>S  ( n1 -- ca len )
  \ Convert two characters to a string.
  \ high byte of n1 = first character
  \ low byte of n1 = second character
  PAD ! PAD 2  ;

: KEY-NAME  ( a -- ca len )
  \ Convert a key identifier to its key name.
  \ a = key address in the `KEYS` table
  4 + @ DUP 256 U< IF  C>S  ELSE  2C>S  THEN  ;

( PRESSED? PRESSED )

: PRESSED?  ( a -- f )
  \ Is a key pressed?
  \ a = key address in the `KEYS` table
  2@ INP AND 0=  ;

: (PRESSED)  ( -- a tf | ff tf | ff )
  \ Check all keys.
  \ If a key is pressed, return its address in the `KEYS` table
  \ and a true flag; if Break is pressed, return a false flag
  \ and a true flag; else return a false flag.
  FALSE  \ default
  [ KEYS #KEYS /KEY * BOUNDS SWAP ] LITERAL LITERAL DO
    ?TERMINAL IF  TRUE UNLOOP EXIT  THEN
    I PRESSED? IF  DROP I TRUE UNLOOP EXIT  THEN
  /KEY +LOOP  ;

: PRESSED  ( -- a | ff )
  \ Check all keys forever until one of them is pressed
  \ and return its identifier.
  \ If a valid key was pressed, return its address
  \ in the `KEYS` table; if the "Break" key was pressed,
  \ return a false flag.
  \ a = address in the `KEYS` table
  BEGIN  (PRESSED)  UNTIL  ;

  \ vim: filetype=abersoftforth
