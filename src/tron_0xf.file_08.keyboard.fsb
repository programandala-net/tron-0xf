.( Tron 0xF: keyboard )

\ tron_0xf.file_08.keyboard.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

  \ -----------------------------------------------------------

  \ `caps-shift-key` will be updated later with the address of
  \ the Caps Shift key in the keys table. It is used to prevent
  \ this key from being chosen in the configuration menu, in
  \ order to make it impossible to press the Break key (Caps
  \ Shift + 1 or Caps Shift + Space) unintentionally during the
  \ game.
0 value caps-shift-key

2 10 thru

( y/n input )

: y/n?  ( c -- f )
  \ Is the given (uppercase) char c
  \ a valid answer for a y/n question?
  dup 'y' = swap 'n' = or  ;

: y/n  ( -- c )
  \ Wait for a valid key press for a y/n question
  \ and return its code.
  begin  akey upperc dup y/n? 0=  while  drop  repeat
  key-sound  ;

: no?  ( -- f )
  \ Wait for a valid key press for a y/n question
  \ and return a flag: Was it "N" or "n"?
  \ (or the correspondent letters in the current language).
  y/n 'n' =  ;

: yes?  ( -- f )
  \ Wait for a valid key press for a y/n question
  \ and return a flag: Was it "Y" or "y"?
  \ (or the correspondent letters in the current language).
  y/n 'y' =  ;

( Keyboard messages and prompts )

: wait-any-key  ( -- )
  500 ms  akey drop key-sound  ;

: press-any-key  ( -- )
  \ Print "press any key" in the current language
  \ and wait for a key press.
  press-any-key$ remark wait-any-key  ;

: more  ( -- )
  \ Wait for a key press and prepare the screen
  \ for a new contents page.
  reveal-contents press-any-key wipe-contents  ;

: .do-stop  ( -- )
  \ Print "Do you want to stop?" in the current language.
  do-stop$ [ lines 2 / 1 - ] literal white ink |linetype|  ;

: do-stop?  ( -- f )
  \ Ask "Do you want to stop?" in the current language
  \ and return flag with the answer (true=yes).
  .do-stop yes?  ;

( keys table, rows 1-5 Q-T )

40 constant #keys   \ number of keys of ZX Spectrum
 6 constant /key    \ bytes per key in the table

  \ Convert two characters to a 16-bit number.
: special-key-name  ( c1 c2 -- n )  256 * +  ;

here: keys

  \ Every element of the `keys` table 
  \ has the following structure:

  \ +0 = port of the keyboard row (2 bytes)
  \ +2 = bitmask of the key (2 bytes, but only the LSB is used)
  \ +4 = key name (2 bytes): one letter (the second byte is
  \      zero and will be ignored) or two letters.
  
  \ Keys are identified by their absolute address in the table.
  \
  \ The players' default keys are set while the table is being
  \ compiled, by storing the dictionary pointer into a player
  \ variable.
  \
  \ The default keys of players 1 and 3 correspond to the
  \ Sinclair joysticks (keys 1-4 and 6-9); the default keys of
  \ player 2 are suitable for the Dvorak keyboard layout (keys
  \ K, X, B, M).

hex                   here left-k0 !    \ "1"
char 1 01 F7FE , , ,  here right-k0 !   \ "2"
char 2 02 F7FE , , ,  here up-k0 !      \ "3"
char 3 04 F7FE , , ,  here down-k0 !    \ "4"
char 4 08 F7FE , , ,  here left-k1 !    \ "5"
char 5 10 F7FE , , , 

char Q 01 FBFE , , ,
char W 02 FBFE , , ,
char E 04 FBFE , , ,
char R 08 FBFE , , ,
char T 10 FBFE , , ,

( keys table, rows A-G CS-V 0-6 )

char A 01 FDFE , , ,
char S 02 FDFE , , ,
char D 04 FDFE , , ,
char F 08 FDFE , , ,
char G 10 FDFE , , ,  here to caps-shift-key

char C char S special-key-name 01 FEFE , , ,  \ Caps Shift
char Z 02 FEFE , , ,  here right-k2 ! \ "X"
char X 04 FEFE , , ,
char C 08 FEFE , , ,
char V 10 FEFE , , ,

char 0 01 EFFE , , ,
char 9 02 EFFE , , ,  here right-k1 ! \ "8"
char 8 04 EFFE , , ,  here up-k1 !    \ "7"
char 7 08 EFFE , , ,  here down-k1 !  \ "6"
char 6 10 EFFE , , ,

( keys table, rows P-Y En-H )

char P 01 DFFE , , ,
char O 02 DFFE , , ,
char I 04 DFFE , , ,
char U 08 DFFE , , ,
char Y 10 DFFE , , ,

char E char n special-key-name 01 BFFE , , ,  \ Enter
char L 02 BFFE , , ,  here left-k2 !  \ "K"
char K 04 BFFE , , ,
char J 08 BFFE , , ,
char H 10 BFFE , , ,

( keys table, row Sp-B )

char S char p special-key-name 01 7FFE , , ,  \ Space
char S char S special-key-name 02 7FFE , , ,  \ Symbol Shift
                      here down-k2 !  \ "M"
char M 04 7FFE , , ,
char N 08 7FFE , , ,  here up-k2 !    \ "B"
char B 10 7FFE , , ,

decimal

( k#>a key-name )

: k#>a  ( n -- a )
  \ Convert a key number to its address in `KEYS`.
  /key * keys +  ;

: c>s  ( c -- ca len )
  \ Convert a character to a string.
  pad c! pad 1  ;

: 2c>s  ( n1 -- ca len )
  \ Convert two characters to a string.
  \ high byte of n1 = first character
  \ low byte of n1 = second character
  pad ! pad 2  ;

: key-name  ( a -- ca len )
  \ Convert a key identifier to its key name.
  \ a = key address in the `keys` table
  4 + @ dup 256 u< if  c>s  else  2c>s  then  ;

( pressed? pressed|break )

: pressed?  ( a -- f )
  \ Is a key pressed?
  \ a = key address in the `keys` table
  2@ inp and 0=  ;

;S  \ ignore the rest of the screen

  \ XXX OLD -- not used any more

: (pressed|break)  ( -- a tf | ff tf | ff )
  \ Check all keys.
  \ If a key is pressed, return its address in the `keys` table
  \ and a true flag; if "Break" is pressed, return a false flag
  \ and a true flag; else return a false flag.
  false  \ default
  [ keys #keys /key * bounds swap ] literal literal do
    ?terminal if  true unloop exit  then
    i pressed? if  drop i true unloop exit  then
  /key +loop  ;

: pressed|break  ( -- a | ff )
  \ Check all keys forever until one of them,
  \ or the "Break" key, is pressed.
  \ If a valid key was pressed, return its address
  \ in the `keys` table; if the "Break" key was pressed,
  \ return a false flag.
  \ a = address in the `keys` table
  begin  (pressed|break)  until  ;

( pressed )

: (pressed)  ( -- a tf | ff )
  \ Check all keys.
  \ If a key is pressed, return its address in the `keys` table
  \ and a true flag; else return a false flag.
  \ a = address in the `keys` table
  false  \ default
  [ keys #keys /key * bounds swap ] literal literal do
    i pressed? if  drop i true unloop exit  then
  /key +loop  ;

: pressed  ( -- a )
  \ Check all keys forever until one of them is pressed.
  \ Return its address in the `keys` table.
  \ a = address in the `keys` table
  begin  (pressed)  until  ;

  \ vim: filetype=abersoftforthafera
