.( Tron 0xF: keyboard )

\ tron_0xf.file_08.keyboard.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

  \ -----------------------------------------------------------

  \ The author would be grateful for any constructive
  \ suggestions and bug-reports, via
  \ <http://programandala.net>.

  \ -----------------------------------------------------------

  \ `caps-shift-key` will be updated later with the address of
  \ the Caps Shift key in the keys table. It is used to prevent
  \ this key from being chosen in the configuration menu, in
  \ order to make it impossible to press the Break key (Caps
  \ Shift + 1 or Caps Shift + Space) unintentionally during the
  \ game.
0 value caps-shift-key

2 9 thru

( y/n input )

  \ Is the given (uppercase) char c
  \ a valid answer for a y/n question?
: y/n?  ( c -- f )  dup 'y' = swap 'n' = or  ;

: y/n  ( -- c )
  \ Wait for a valid key press for a y/n question
  \ and return its code.
  begin  akey upperc dup y/n? 0=  while  drop  repeat
  key-sound  ;

  \ Wait for a valid key press for a y/n question
  \ and return a flag: Was it "N" or "n"?
  \ (or the correspondent letters in the current language).
: no?  ( -- f )  y/n 'n' =  ;

  \ Wait for a valid key press for a y/n question
  \ and return a flag: Was it "Y" or "y"?
  \ (or the correspondent letters in the current language).
: yes?  ( -- f )  y/n 'y' =  ;

( Keyboard messages and prompts )

: wait-any-key  ( -- )  500 ms  akey drop key-sound  ;

  \ Print "press any key" in the current language
  \ and wait for a key press.
: press-any-key  ( -- )  press-any-key$ remark wait-any-key  ;

  \ Wait for a key press and prepare the screen
  \ for a new contents page.
: more  ( -- )  reveal-contents press-any-key wipe-contents  ;

( keys table, rows 1-5 Q-T )

40 constant #keys   \ number of keys of ZX Spectrum
 5 constant /key    \ bytes per key in the table

  \ XXX OLD
  \ Convert two characters to a 16-bit number.
  \ : special-key-name  ( c1 c2 -- n )  256 * +  ;

here: keys

  \ Every element of the `keys` table 
  \ has the following structure:

  \ +0 = port of the keyboard row (2 bytes)
  \ +2 = bitmask of the key (2 bytes, but only the LSB is used)
  \ +4 = key name (1 byte), an ASCII character or an UDG
  
  \ Keys are identified by their absolute address in the table.
  \
  \ The players' default keys are set while the table is being
  \ compiled, by storing the dictionary pointer into a player
  \ variable.
  \
  \ The default keys of players 1 and 3 correspond to the
  \ Sinclair joysticks (keys 1-4 and 6-9); the default keys of
  \ player 2 are suitable for the Dvorak keyboard layout (keys
  \ K, X, B, M).

hex                    here left-k0 !    \ "1"
char 1 01 F7FE , , c,  here right-k0 !   \ "2"
char 2 02 F7FE , , c,  here up-k0 !      \ "3"
char 3 04 F7FE , , c,  here down-k0 !    \ "4"
char 4 08 F7FE , , c,  here left-k1 !    \ "5"
char 5 10 F7FE , , c, 

char Q 01 FBFE , , c,
char W 02 FBFE , , c,
char E 04 FBFE , , c,
char R 08 FBFE , , c,
char T 10 FBFE , , c,

( keys table, rows A-G CS-V 0-6 )

char A 01 FDFE , , c,
char S 02 FDFE , , c,
char D 04 FDFE , , c,
char F 08 FDFE , , c,
char G 10 FDFE , , c,  here to caps-shift-key

    98 01 FEFE , , c,  \ Caps Shift (symbol in UDG)
char Z 02 FEFE , , c,  here right-k2 ! \ "X"
char X 04 FEFE , , c,
char C 08 FEFE , , c,
char V 10 FEFE , , c,

char 0 01 EFFE , , c,
char 9 02 EFFE , , c,  here right-k1 ! \ "8"
char 8 04 EFFE , , c,  here up-k1 !    \ "7"
char 7 08 EFFE , , c,  here down-k1 !  \ "6"
char 6 10 EFFE , , c,

( keys table, rows P-Y En-H )

char P 01 DFFE , , c,
char O 02 DFFE , , c,
char I 04 DFFE , , c,
char U 08 DFFE , , c,
char Y 10 DFFE , , c,

    99 01 BFFE , , c,  \ Enter (symbol in UDG)
char L 02 BFFE , , c,  here left-k2 !  \ "K"
char K 04 BFFE , , c,
char J 08 BFFE , , c,
char H 10 BFFE , , c,

( keys table, row Sp-B; k#>a key-name )

    9A 01 7FFE , , c,  \ Space (symbol in UDG)
    9B 02 7FFE , , c,  \ Symbol Shift (symbol in UDG)
                      here down-k2 !  \ "M"
char M 04 7FFE , , c,
char N 08 7FFE , , c,  here up-k2 !    \ "B"
char B 10 7FFE , , c,

decimal

  \ Convert a key number to its key address.
: k#>a  ( n -- a )  /key * keys +  ;

  \ Convert a key address to its key name character.
  \ Note: `graph-udg` must be used before printing it
  \ (and `lang-udg` after) because some key names use UDG.
  \ a = key address in the `keys` table
: key-name  ( a -- c )  4 + c@  ;

( pressed? pressed|break )

: pressed?  ( a -- f )
  \ Is a key pressed?
  \ a = key address in the `keys` table
  2@ inp and 0=  ;

;S  \ ignore the rest of the screen

  \ XXX OLD -- not used any more

: (pressed|break)  ( -- a tf | ff tf | ff )
  \ Check all keys.
  \ If a key is pressed, return its address in the `keys` table
  \ and a true flag; if "Break" is pressed, return a false flag
  \ and a true flag; else return a false flag.
  false  \ default
  [ keys #keys /key * bounds swap ] literal literal do
    ?terminal if  true unloop exit  then
    i pressed? if  drop i true unloop exit  then
  /key +loop  ;

: pressed|break  ( -- a | ff )
  \ Check all keys forever until one of them,
  \ or the "Break" key, is pressed.
  \ If a valid key was pressed, return its address
  \ in the `keys` table; if the "Break" key was pressed,
  \ return a false flag.
  \ a = address in the `keys` table
  begin  (pressed|break)  until  ;

( pressed )

: (pressed)  ( -- a tf | ff )
  \ Check all keys.
  \ If a key is pressed, return its address in the `keys` table
  \ and a true flag; else return a false flag.
  \ a = address in the `keys` table
  false  \ default
  [ keys #keys /key * bounds swap ] literal literal do
    i pressed? if  drop i true unloop exit  then
  /key +loop  ;

: pressed  ( -- a )
  \ Check all keys forever until one of them is pressed.
  \ Return its address in the `keys` table.
  \ a = address in the `keys` table
  begin  (pressed)  until  ;

  \ vim: filetype=abersoftforthafera
