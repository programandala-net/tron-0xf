\ tron.file_05.keyboard.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in Abersoft Forth

\ Copyright (C) 1985,2009,2015 Marcos Cruz (programandala.net)
\ Licencia/Permesilo/License: GPL 3

\ http://programandala.net/en.program.tron_0xf.html

.( Tron: keyboard )

2 10 THRU

( Player keys )

4 CONSTANT KEYS/PLAYER  \ keys defined per player

  \ Every player has a table with her defined keys, in the
  \ following order: up, down, left, right.  They are the key
  \ addresses in the `KEYS` table.

  \ The constants hold the specific addresses in the table
  \ and thus they work like variables.

KEYS/PLAYER CELLS BUFFER: KEYS1
  KEYS1           CONSTANT UP-K1
  KEYS1 CELL+     CONSTANT DOWN-K1
  KEYS1 2 CELLS + CONSTANT LEFT-K1
  KEYS1 3 CELLS + CONSTANT RIGHT-K1

( Player keys )

KEYS/PLAYER CELLS BUFFER: KEYS2
  KEYS2           CONSTANT UP-K2
  KEYS2 CELL+     CONSTANT DOWN-K2
  KEYS2 2 CELLS + CONSTANT LEFT-K2
  KEYS2 3 CELLS + CONSTANT RIGHT-K2

KEYS/PLAYER CELLS BUFFER: KEYS3
  KEYS3           CONSTANT UP-K3
  KEYS3 CELL+     CONSTANT DOWN-K3
  KEYS3 2 CELLS + CONSTANT LEFT-K3
  KEYS3 3 CELLS + CONSTANT RIGHT-K3

( KEYS table )

40 CONSTANT #KEYS  \ number of keys of ZX Spectrum
 6 CONSTANT /KEY  \ bytes per key in the table

: SPECIAL-KEY-NAME  ( c1 c2 -- n )
  \ Convert two characters to a 16-bit number.
  256 * +  ;

HERE: KEYS

  \ Every element of the `KEYS` table 
  \ has the following structure:

  \ +0 = port of the keyboard row (2 bytes)
  \ +2 = bitmask of the key (2 bytes, but only the LSB is used)
  \ +4 = key name (2 bytes): one letter (the second byte
  \      will be ignored) or two letters.
  
  \ Elements are identified by their absolute address in the
  \ table. The players' default keys are set while the table is
  \ being compiled.

HEX

( KEYS table, rows 1-5 Q-T A-G )

CHAR 1 01 F7FE , , ,
CHAR 2 02 F7FE , , ,
CHAR 3 04 F7FE , , ,
CHAR 4 08 F7FE , , ,  HERE LEFT-K1 ! \ the "5" key
CHAR 5 10 F7FE , , , 

CHAR Q 01 FBFE , , ,  HERE UP-K2 !    \ XXX TMP
CHAR W 02 FBFE , , ,  HERE DOWN-K2 !  \ XXX TMP
CHAR E 04 FBFE , , ,  HERE LEFT-K2 !  \ XXX TMP
CHAR R 08 FBFE , , ,  HERE RIGHT-K2 ! \ XXX TMP
CHAR T 10 FBFE , , ,

CHAR A 01 FDFE , , ,  HERE UP-K3 !    \ XXX TMP
CHAR S 02 FDFE , , ,  HERE DOWN-K3 !  \ XXX TMP
CHAR D 04 FDFE , , ,  HERE LEFT-K3 !  \ XXX TMP
CHAR F 08 FDFE , , ,  HERE RIGHT-K3 ! \ XXX TMP
CHAR G 10 FDFE , , ,

( KEYS table, rows CS-V 0-9 P-Y )

CHAR C CHAR S SPECIAL-KEY-NAME 01 FEFE , , ,  \ Caps Shift
CHAR Z 02 FEFE , , ,
CHAR X 04 FEFE , , ,
CHAR C 08 FEFE , , ,
CHAR V 10 FEFE , , ,

CHAR 0 01 EFFE , , ,
CHAR 9 02 EFFE , , ,  HERE RIGHT-K1 !  \ the "8" key
CHAR 8 04 EFFE , , ,  HERE UP-K1 !     \ the "7" key
CHAR 7 08 EFFE , , ,  HERE DOWN-K1 !   \ the "6" key
CHAR 6 10 EFFE , , ,

CHAR P 01 DFFE , , ,
CHAR O 02 DFFE , , ,
CHAR I 04 DFFE , , ,
CHAR U 08 DFFE , , ,
CHAR Y 10 DFFE , , ,

( KEYS table, rows EN-H SP-B )

CHAR E CHAR n SPECIAL-KEY-NAME 01 BFFE , , ,  \ Enter
CHAR L 02 BFFE , , ,
CHAR K 04 BFFE , , ,
CHAR J 08 BFFE , , ,
CHAR H 10 BFFE , , ,

CHAR S CHAR p SPECIAL-KEY-NAME 01 7FFE , , ,  \ Space
CHAR S CHAR S SPECIAL-KEY-NAME 02 7FFE , , ,  \ Symbol Shift
CHAR M 04 7FFE , , ,
CHAR N 08 7FFE , , ,
CHAR B 10 7FFE , , ,

DECIMAL

( K#>A KEY-NAME )

: K#>A  ( n -- a )
  \ Convert a key number to its address in `KEYS`.
  /KEY * KEYS +  ;

: C>S  ( c -- ca len )
  \ Convert a character to a string.
  PAD C! PAD 1  ;

: 2C>S  ( 16bit -- ca len )
  \ Convert two characters to a string.
  \ high byte of n1 = first character
  \ low byte of n1 = second character
  PAD ! PAD 2  ;
  

: KEY-NAME  ( a -- ca len )
  \ Convert a key identifier to its key name.
  \ a = key address in the `KEYS` table
  4 + @ DUP 256 U< IF  C>S  ELSE  2C>S  THEN  ;

( PRESSED? PRESSED )

: PRESSED?  ( a -- f )
  \ Is a key pressed?
  \ a = key address in the `KEYS` table
  2@ INP AND 0=  ;

: (PRESSED)  ( -- a tf | ff )
  \ Check all keys.
  \ a = key address in the `KEYS` table
  FALSE  \ default
  [ KEYS #KEYS /KEY * BOUNDS SWAP ] LITERAL LITERAL DO
    I PRESSED? IF  DROP I TRUE LEAVE  THEN
  /KEY +LOOP  ;

: PRESSED  ( -- a )
  \ Check all keys forever until one of them is pressed
  \ and return its identifier.
  \ a = key address in the `KEYS` table
  BEGIN  (PRESSED) ?EXIT  AGAIN  ;

  \ vim: filetype=abersoftforth:fileencoding=utf-8
