.( Tron 0xF: game -- part 2 )

\ tron_0xf.file_11.game.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

  \ -----------------------------------------------------------

2 8 thru

( -1|1 )

create -1|1  ( -- -1 | 1 )
  \ Return a random increment for a graphic coordinate.
  hex

  \ XXX OLD -- first version, with memory address as seed
  \   here 1+             \ local_seed: equ $+1
  \   21 c, 0 ,           \ ld hl,the_seed ; patched
  \   5C76 @ over ! \ patch the_seed with system FRAMES
  \   7E c,               \ ld a,(hl)
  \   23 c,               \ inc hl
  \   22 c, ,             \ ld (local_seed),hl

  \ XXX NEW -- second version, with register R
  \ (not better results, but faster and smaller code)
  ED c, 5F C,         \ ld a,r

  E6 c, 01 c,         \ and 1 ; bit 0 only
  26 c, 00 c,         \ ld h,0
  68 07 + c,          \ ld l,a
  C2 c, pushhl ,      \ jp nz,PUSHHL ; return 1
  2B c,               \ dec hl
  C3 c, pushhl ,      \ jp pushhl ; return -1
  smudge decimal

( incs2* )

create incs2*  ( b1 b2 -- b1' b2' )  hex
  \ Double the coordinate increments b1 and b2
  \ by shifting them left directly on the stack.
  \ b1' = b1 2*
  \ b2' = b2 2*
  21 c, 0 ,       \ ld hl,0
  39 c,           \ add hl,sp ; low byte of TOS
  CB c, 26 c,     \ sla (hl)
  23 c,           \ inc hl ; high byte of TOS
  23 c,           \ inc hl ; low byte of 2TOS
  CB c, 26 c,     \ sla (hl)
  C3 c, next ,    \ jp next
  smudge decimal

( Robot pilot)

: crashing?  ( xinc yinc -- f )
  \ Considering the given coordinate increments
  \ for the current player,
  \ is the second next position occupied?
  incs2* player-yc @ + swap player-xc @ + swap point  ;

: dodged?  ( xinc yinc -- f )
  \ Considering the given coordinate increments
  \ for the current player,
  \ is the second next position free?
  crashing? 0=  ;

: dodge-y  ( -- 0 yinc )
  \ Choose random increments to start moving on the Y axis.
  0 -1|1 2dup dodged? ?exit  minus  ;

: dodge-x  ( -- xinc 0 )
  \ Choose random increments to start moving on the X axis.
  -1|1 0 2dup dodged? ?exit  swap minus swap  ;

: dodge  ( -- )
  \ Change the direction of the current player.
  set-turn-sound player-xinc @   \ moving on the X axis?
  if  dodge-y  else  dodge-x  then  player-incs 2!  ;

:noname  ( -- )
  \ Control procedure for robot pilots.
  \ Update the coordinate increments
  \ of the current (robot) player:
  \ If there's something ahead, change the direction.
  player-incs 2@ crashing?  if  dodge  then
  ; is (robot)

( Human pilot)

: turn  ( d -- )  player-incs 2! set-turn-sound  ;

:noname  ( -- )
  \ Control procedure for human pilots.
  \ Update the coordinate increments
  \ of the current (human) player.
  player-up-k @ pressed?  if
    player-xinc @ if  up-incs turn  then  exit  then
  player-down-k @ pressed? if
    player-xinc @ if  down-incs turn  then  exit  then
  player-left-k @ pressed? if
    player-yinc @ if  left-incs turn  then  exit  then
  player-right-k @ pressed? if
    player-yinc @ if  right-incs turn  then  then 
  ; is (human)

( duel )

: forward  ( -- )
  \ Update the coordinates of the current player.
  player-xinc @ player-xc +!  player-yinc @ player-yc +!  ;

: stop?  ( -- f )
  \ f = confirmed Break key?
  false  ?terminal 0= ?exit   \ no Break key
  drop save-display do-stop?  \ ask for confirmation
  dup 0= if  restore-display  then  ;

( duel )

: duel  ( -- f )
  \ Game duel. Stop when a player crashes
  \ or the break key is pressed and confirmed.
  \ f = Break key pressed and confirmed?
  duel-init  begin
    max-players 0 do  i player!
      player-control @ -dup if
        execute crash? if
          killed last-one? if  winner unloop false exit  then
        else  forward paint noise  then
      then
    loop
  stop? until  true  ;

( game )

: ?duel-end  ( f -- )
  \ XXX TMP
  ?exit  akey drop  ;

: game  ( -- )
  \ Game loop.
  game-init begin  duel dup 0= ?duel-end  until  page   ;

  \ vim: filetype=abersoftforthafera
