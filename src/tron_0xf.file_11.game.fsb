.( Tron 0xF: game -- part 2 )

\ tron_0xf.file_11.game.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

2 11 thru

( Rudder increments)

 \ Coordinate increments.
 \ Double constants are used to update the coordinate
 \ increments faster.

 \ X  Y 
   0  1 2constant up-incs
   0 -1 2constant down-incs
  -1  0 2constant left-incs
   1  0 2constant right-incs

( -1|1 )

create -1|1  ( -- -1 | 1 )
  \ Return a random increment for a graphic coordinate.
  hex
  here 1+             \ local_seed: equ $+1
  21 c, 0 ,           \ ld hl,the_seed ; patched
  5C76 @ over ! \ patch the_seed with system FRAMES
  7E c,               \ ld a,(hl)
  23 c,               \ inc hl
  22 c, ,             \ ld (local_seed),hl
  E6 c, 01 c,         \ and 1 ; bit 0 only
  26 c, 00 c,         \ ld h,0
  68 07 + c,          \ ld l,a
  C2 c, pushhl ,      \ jp nz,PUSHHL ; return 1
  2B c,               \ dec hl
  C3 c, pushhl ,      \ jp pushhl ; return -1
  smudge decimal

( incs2* )

create incs2*  ( b1 b2 -- b1' b2' )  hex
  \ Double the coordinate increments b1 and b2
  \ by shifting them left directly on the stack.
  \ b1' = b1 2*
  \ b2' = b2 2*
  21 c, 0 ,       \ ld hl,0
  39 c,           \ add hl,sp ; low byte of TOS
  CB c, 26 c,     \ sla (hl)
  23 c,           \ inc hl ; high byte of TOS
  23 c,           \ inc hl ; low byte of 2TOS
  CB c, 26 c,     \ sla (hl)
  C3 c, next ,    \ jp next
  smudge decimal

( Robot pilot)

: crashing?  ( xinc yinc -- f )
  \ Considering the given coordinate increments
  \ for the current player,
  \ is the second next position occupied?
  \ XXX TODO faster in Z80
  incs2* player-yc @ + swap player-xc @ + swap point  ;

: dodged?  ( xinc yinc -- f )
  \ Considering the given coordinate increments
  \ for the current player,
  \ is the second next position free?
  crashing? 0=  ;

: dodge-y  ( -- 0 yinc )
  \ Choose increments to start moving on the Y axis.
  0 -1|1 2dup dodged? ?exit  minus  ;

: dodge-x  ( -- xinc 0 )
  \ Choose increments to start moving on the X axis.
  -1|1 0 2dup dodged? ?exit  swap minus swap  ;

: dodge  ( -- )
  \ Change the direction of the current player.
  set-turn-sound player-xinc @   \ moving on the X axis?
  if  dodge-y  else  dodge-x  then  player-incs 2!  ;

:noname  ( -- )
  \ Control procedure for robot pilots.
  \ Update the coordinate increments
  \ of the current (robot) player:
  \ If there's something ahead, change the direction.
  player-incs 2@ crashing?  if  dodge  then
  ; is (robot)

( Human pilot)

: turn  ( d -- )  player-incs 2! set-turn-sound  ;

:noname  ( -- )
  \ Control procedure for human pilots.
  \ Update the coordinate increments
  \ of the current (human) player.
  player-up-k @ pressed?  if
    player-xinc @ if  up-incs turn  then  exit  then
  player-down-k @ pressed? if
    player-xinc @ if  down-incs turn  then  exit  then
  player-left-k @ pressed? if
    player-yinc @ if  left-incs turn  then  exit  then
  player-right-k @ pressed? if
    player-yinc @ if  right-incs turn  then  then 
  ; is (human)

( positions-table )

:noname
  ( -- col0 x0 y0 x-inc0 y-inc0 ... col2 x2 y2 x-inc2 y-inc2 )
  \ Score column, start screen position and increments,
  \ for three players.
   1 126  40 up-incs    
  14 215 127 left-incs  
  28  40 127 right-incs ;

:noname
  ( -- col0 x0 y0 x-inc0 y-inc0 col1 x1 y1 x-inc1 y-inc1 )
  \ Score column, start screen position and increments,
  \ for two players.
   1 215 88 left-incs 
  28  40 88 right-incs  ;

:noname
  ( -- col0 x0 y0 x-inc0 y-inc0 )
  \ Score column, start screen position and increments,
  \ for one player.
  14 127 88 up-incs  ;

here: positions-table
  \ Execution table for `positions`.
  ( cfa3 cfa2 cfa1 )
  , , ,
 
( positions ready )

: positions  ( -- )
  \ Set the players' start positions.
  \ First, get the positions needed for the number of players:
  players 1- cells positions-table + @ execute
  \ Second, store them into the players:
  max-players 0 do  i player!
    someone? if
      player-incs 2! player-yc ! player-xc ! player-score-col ! 
    then
  loop  ;

: ready  ( -- )
  \ Show all players at their start positions.
  positions  max-players 0 do
    i player!  someone? if  paint  then
  loop  ;

( round )

  \ Init a game round.
  \ XXX TODO message
: round-init  ( -- )  clear-arena ready akey drop  ;

: forward  ( -- )
  \ Update the coordinates of the current player.
  player-xinc @ player-xc +!  player-yinc @ player-yc +!  ;

: stop?  ( -- f )
  false  ?terminal 0= ?exit  drop save-display do-stop?
  dup 0= if  restore-display  then  ;

( round )

0 variable crashes

: round  ( -- f )
  \ Game round, until a crash happens
  \ or the break key is pressed and confirmed.
  \ f = Break key pressed?
  round-init
  begin

    \ XXX NEW method
    \ crashes off

    max-players 0 do
      i player!  player-pilot @ -dup if
        execute

        \ XXX OLD method
        \ XXX FIXME when 2 robots play, they crash
        crash? if
          \ i quit \ XXX TMP
          crash +scores unloop false exit  then
        forward paint noise
      then
    loop

      \ XXX NEW method -- doesn't makes any difference
      \ XXX FIXME when 2 robots play, they crash
      \ crash? dup crashes +!
      \ 0= if  forward paint noise  then
    \ loop  crashes @ if  crash +scores false exit  then

  stop? until  true  ;

( game )

  \ XXX OLD -- not used
  \ : ENOUGH?  ( -- f )
  \   \ No more rounds?
  \   white ink  ANOTHER?$ 12 |linetype|  no?  ;

: -scores  ( -- )
  \ Reset all scores.
  max-players 0 do  i player!  player-score off  loop  ;

: game-init  ( -- )
  \ Init the game.
  cls0 -scores arena save-arena
  set-motor-sound  sound? @ sound  ;

: ?round-end  ( f -- )
  \ XXX TMP
  ?exit  akey drop  ;

: game  ( -- )
  \ Game loop.
  game-init begin  round dup 0= ?round-end  until  page   ;

  \ vim: filetype=abersoftforthafera
