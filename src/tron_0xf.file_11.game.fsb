.( Tron 0xF: game -- part 2 )

\ tron_0xf.file_11.game.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

2 9 thru

( Rudder increments)

 \ Coordinate increments.
 \ Double constants are used to update the coordinate
 \ increments faster.

 \ X  Y 
   0  1 2constant up-incs
   0 -1 2constant down-incs
  -1  0 2constant left-incs
   1  0 2constant right-incs

  \ XXX OLD -- first version:
  \ : -1|1  ( -- -1 | 1 )
  \   \ Return a random increment for a graphic coordinate.
  \   sys-frames c@ 1 and dup ?exit 1-  ;

  \ XXX NEW -- faster version in Z80:
create -1|1  ( -- -1 | 1 )
  \ Return a random increment for a graphic coordinate.
  hex
  3A c, 5C78 ,        \ ld a,(FRAMES)
  E6 c, 01 c,         \ and 1 ; bit 0 only
  26 c, 00 c,         \ ld h,0
  68 07 + c,          \ ld l,a
  C2 c, pushhl ,      \ jp nz,PUSHHL ; return 1
  2B c,               \ dec hl
  C3 c, pushhl ,      \ jp pushhl ; return -1
  smudge decimal

( incs2* )

create incs2*  ( b1 b2 -- b1' b2' )  hex
  \ Double the coordinate increments b1 and b2
  \ by shifting them left directly on the stack.
  \ b1' = b1 2*
  \ b2' = b2 2*
  21 c, 0 ,       \ ld hl,0
  39 c,           \ add hl,sp ; low byte of TOS
  CB c, 26 c,     \ sla (hl)
  23 c,           \ inc hl ; high byte of TOS
  23 c,           \ inc hl ; low byte of 2TOS
  CB c, 26 c,     \ sla (hl)
  C3 c, next ,    \ jp next
  smudge decimal

( Robot pilot)

: crashing?  ( xinc yinc -- f )
  \ Considering the given coordinate increments
  \ for the current player,
  \ is the second next position occupied?
  \ XXX TODO faster in Z80
  incs2* player-yc @ + swap player-xc @ + swap point  ;

: dodged?  ( xinc yinc -- f )
  \ Considering the given coordinate increments
  \ for the current player,
  \ is the second next position free?
  crashing? 0=  ;

: dodge-y  ( -- 0 yinc )
  \ Choose increments to start moving on the Y axis.
  0 -1|1 2dup dodged? ?exit  minus  ;

: dodge-x  ( -- xinc 0 )
  \ Choose increments to start moving on the X axis.
  -1|1 0 2dup dodged? ?exit  swap minus swap  ;

: dodge  ( -- )
  \ Change the direction of the current player.
  set-turn-sound player-xinc @   \ moving on the X axis?
  if  dodge-y  else  dodge-x  then  player-incs 2!  ;

:noname  ( -- )
  \ Control procedure for robot pilots.
  \ Update the coordinate increments
  \ of the current (robot) player:
  \ If there's something ahead, change the direction.
  player-incs 2@ crashing?  if  dodge  then
  ; is (robot)

( Human pilot)

: turn  ( d -- )  player-incs 2! set-turn-sound  ;

:noname  ( -- )
  \ Control procedure for human pilots.
  \ Update the coordinate increments
  \ of the current (human) player.
  player-up-k @ pressed?  if
    player-xinc @ if  up-incs turn  then  exit  then
  player-down-k @ pressed? if
    player-xinc @ if  down-incs turn  then  exit  then
  player-left-k @ pressed? if
    player-yinc @ if  left-incs turn  then  exit  then
  player-right-k @ pressed? if
    player-yinc @ if  right-incs turn  then  then 
  ; is (human)

( positions ready )

:noname  ( -- )
  \ Set the players' positions before a new round,
  \ for three players.
   40 xc0 ! 127 yc0 !  right-incs incs0 2!
  215 xc1 ! 127 yc1 !  left-incs  incs1 2!
  126 xc2 !  40 yc2 !  up-incs    incs2 2!  ;

:noname  ( -- )
  \ Set the players' positions before a new round,
  \ for two players.
   40 xc0 ! 88 yc0 !  right-incs incs0 2!
  215 xc1 ! 88 yc1 !  left-incs  incs1 2!  ;

:noname  ( -- )
  \ Set the player's position before a new round,
  \ for one player.
  127 xc0 ! 88 yc0 !  up-incs incs0 2!  ;

here: positions-table  ( cfa3 cfa2 cfa1 )
  \ Execution table for `POSITIONS`.
  , , ,
 
: positions  ( -- )
  \ Set the players' start positions.
  players 1- cells positions-table + @ execute  ;

: ready  ( -- )
  \ Show all players at their start positions.
  positions  players 0 do  i player! paint  loop  ;

( round )

  \ Init a game round.
  \ XXX TODO message
: round-init  ( -- )  clear-arena ready akey drop  ;

: forward  ( -- )
  \ Update the coordinates of the current player.
  player-xinc @ player-xc +!  player-yinc @ player-yc +!  ;

: stop?  ( -- f )
  false  ?terminal 0= ?exit  drop save-display do-stop?
  dup 0= if  restore-display  then  ;

( round )

0 variable crashes

: round  ( -- f )
  \ Game round, until a crash happens
  \ or the break key is pressed and confirmed.
  \ f = Break key pressed?
  round-init
  begin

    \ XXX NEW method
    \ crashes off

    players 0 do
      i player!  player-pilot @ execute

      \ XXX OLD method
      \ XXX FIXME when 2 robots play, they crash
      crash? if
        \ i quit \ XXX TMP
        crash +scores unloop false exit  then
      forward paint noise
     loop

      \ XXX NEW method -- doesn't makes any difference
      \ XXX FIXME when 2 robots play, they crash
      \ crash? dup crashes +!
      \ 0= if  forward paint noise  then
    \ loop  crashes @ if  crash +scores false exit  then

  stop? until  true  ;

( game )

  \ XXX OLD -- not used
  \ : ENOUGH?  ( -- f )
  \   \ No more rounds?
  \   white ink  ANOTHER?$ 12 |linetype|  no?  ;

: -scores  ( -- )
  \ Reset all scores.
  players 0 do  i player!  player-score off  loop  ;

: game-init  ( -- )
  \ Init the game.
  cls0 -scores arena save-arena
  set-motor-sound  sound? @ sound  ;

: ?round-end  ( f -- )
  \ XXX TMP
  ?exit  akey drop  ;

: game  ( -- )
  \ Game loop.
  game-init begin  round dup 0= ?round-end  until  page   ;

  \ vim: filetype=abersoftforthafera
