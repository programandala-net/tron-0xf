.( Tron 0xF: data )

\ tron_0xf.file_01.data.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

forth definitions

  \ Memory addresses and sizes

22528 constant attributes  768 constant /attributes

  \ System variables

23606 constant sys-chars    23675 constant sys-udg
23677 constant sys-x-coord  23678 constant sys-y-coord

2 11 thru

( Colors)

  \ Color constants

0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

: papery  ( color -- paper-attribute )  8 *  ;

( Vocabulary, languages, players types)

: task  ;  vocabulary tron immediate  tron definitions

  \ Languages

 3 constant langs  \ number of languages
 0 constant en     \ English
 1 constant eo     \ Esperanto
 2 constant es     \ Spanish
en value lang   \ current language

3 constant max-players  \ maximum number of players
3 value players         \ number of players

4 constant keys/player  \ keys per player

  \ Type of players. The cfa of the control word is stored into
  \ the correspondent player variable, ready to be executed
  \ during the game. `none` is a special case, skipped by the
  \ game loop.

defer (human)  ' (human) cfa constant human
defer (robot)  ' (robot) cfa constant robot
                           0 constant none

( Players data)

12 cells constant /player-data \ bytes per player data

  \ Buffer that holds the data of all players.

/player-data max-players * constant /players-data
/players-data buffer: players-data
players-data /players-data erase

  \ Pointers to the data of every player.

players-data constant player0-data
player0-data /player-data + constant player1-data
player1-data /player-data + constant player2-data

here: player#-data
  \ Table to access the players' data addresses.
  player0-data , player1-data , player2-data ,

( Specific player data fields )

: player#-variable  ( value field player "name" -- )

  \ Create a player variable.

  \ A player# variable is a constant that points to a data
  \ field of a specific player. This way it works like an
  \ ordinary variable, but the player data can be manipulated
  \ also as a whole (e.g. store and fetch the coordinates with
  \ double numbers, for speed; erase the whole zone, etc.).

  /player-data * players-data +  \ player data address
  swap cells +                   \ field address
  dup constant !  ;              \ do it

( Player 0 data fields)

 human  0 0 player#-variable pilot0      \ human or robot
     0  1 0 player#-variable score0      \ score
     0  2 0 player#-variable yc0         \ Y coordinate
     0  3 0 player#-variable xc0         \ X coordinate
     0  4 0 player#-variable yinc0       \ Y inc (-1..1)
     0  5 0 player#-variable xinc0       \ X inc (-1..1)
yellow  6 0 player#-variable color0      \ ink color
     0  7 0 player#-variable up-k0       \ up key
     0  8 0 player#-variable down-k0     \ down key
     0  9 0 player#-variable left-k0     \ left key
     0 10 0 player#-variable right-k0    \ right key
     1 11 0 player#-variable score-col0  \ score column

  \ Double data fields:
yc0   constant coords0
yinc0 constant incs0
  \ Player keys table:
up-k0 constant keys0

( Player 1 data fields)

 robot  0 1 player#-variable pilot1      \ human or robot
     0  1 1 player#-variable score1      \ score
     0  2 1 player#-variable yc1         \ Y coordinate
     0  3 1 player#-variable xc1         \ X coordinate
     0  4 1 player#-variable yinc1       \ Y inc (-1..1)
     0  5 1 player#-variable xinc1       \ X inc (-1..1)
  cyan  6 1 player#-variable color1      \ ink color
     0  7 1 player#-variable up-k1       \ up key
     0  8 1 player#-variable down-k1     \ down key
     0  9 1 player#-variable left-k1     \ left key
     0 10 1 player#-variable right-k1    \ right key
    14 11 1 player#-variable score-col1  \ score column

  \ Double data fields:
yc1   constant coords1
yinc1 constant incs1
  \ Player keys table:
up-k1 constant keys1

( Player 2 data fields)

 robot  0 2 player#-variable pilot2      \ human or robot
     0  1 2 player#-variable score2      \ score
     0  2 2 player#-variable yc2         \ Y coordinate
     0  3 2 player#-variable xc2         \ X coordinate
     0  4 2 player#-variable yinc2       \ Y inc (-1..1)
     0  5 2 player#-variable xinc2       \ X inc (-1..1)
 green  6 2 player#-variable color2      \ ink color
     0  7 2 player#-variable up-k2       \ up key
     0  8 2 player#-variable down-k2     \ down key
     0  9 2 player#-variable left-k2     \ left key
     0 10 2 player#-variable right-k2    \ right key
    28 11 2 player#-variable score-col2  \ score column

  \ Double data fields:
  yc2 constant coords2
yinc2 constant incs2
  \ Player keys table:
up-k2 constant keys2

( Current player's data fields )

  \ Number of the current player (0..2). 
0 value player

  \ Address of the current player's data.
player0-data value player-data

: player!  ( n -- )
  \ Set the current player to 'n'.
  \ n = 0..2
  dup to player  cells player#-data + @ to player-data  ;

: player-variable  ( field "name" -- )

  \ Create a player variable.

  \ A player variable returns the address of a player data
  \ field, depending on the content of `player-data`.  This way
  \ one single word can be used to manage any player.

  <builds   ( n "name" )  cells c,
  does>     ( -- a ) ( pfa )
    c@ player-data +  ;

( Current player data fields )

 0 player-variable player-pilot      \ human, robot
 1 player-variable player-score      \ score
 2 player-variable player-coords     \ both coordinates
 2 player-variable player-yc         \ Y coordinate
 3 player-variable player-xc         \ X coordinate
 4 player-variable player-incs       \ both incs
 4 player-variable player-yinc       \ Y inc (-1..1)
 5 player-variable player-xinc       \ X inc (-1..1)
 6 player-variable player-color      \ ink color
 7 player-variable player-keys       \ keys table
 7 player-variable player-up-k       \ up key
 8 player-variable player-down-k     \ down key
 9 player-variable player-left-k     \  left key
10 player-variable player-right-k    \ right key
11 player-variable player-score-col  \ score column

( Current player calculated fields and other tools)

  \ Is the current player a human pilot?
: human?  ( -- f )  player-pilot @ human =  ;
  
  \ Is the current player "none"? (not human, not robot).
: none?  ( -- f )  player-pilot @ 0=  ;

  \ Is the current player "someone"? (human or robot).
: someone?  ( -- f )  none? 0=  ;

: char-in-string?  ( c ca len -- n tf | ff )
  \ Is the char _c_ in the  string _ca len_?
  \ If so, return its position and a true flag,
  \ else return a false flag.
  over >r bounds do
    dup i c@ = if  drop i unloop r> - true exit  then
  loop  drop rdrop false  ;

  \ vim: filetype=abersoftforthafera
