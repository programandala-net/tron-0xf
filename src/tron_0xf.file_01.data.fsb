.( Tron 0xF: data )

\ tron_0xf.file_01.data.fsb

\ This file is part of
\ Tron 0xF
\ A ZX Spectrum game written in fig-Forth with Abersoft Forth

\ http://programandala.net/en.program.tron_0xf.html

\ Copyright (C) 2015 Marcos Cruz (programandala.net)
\ License: GPL 3

  \ Tron 0xF is free software; you can redistribute it
  \ and/or modify it under the terms of the GNU General Public
  \ License as published by the Free Software Foundation;
  \ either version 3 of the License, or (at your option) any
  \ later version.
  \
  \ Tron 0xF is distributed in the hope that it will be
  \ useful, but WITHOUT ANY WARRANTY; without even the implied
  \ warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  \ PURPOSE.  See the GNU General Public License for more
  \ details.
  \
  \ You should have received a copy of the GNU General Public
  \ License along with Tron 0xF; if not, see
  \ <http://gnu.org/licenses>.

  \ -----------------------------------------------------------

  \ The author would be grateful for any constructive
  \ suggestions and bug-reports, via
  \ <http://programandala.net>.

  \ -----------------------------------------------------------

forth definitions

  20150720.18 2constant version

  \ Color constants

  \ XXX TODO remove the unused
0 constant black    1 constant blue   2 constant red
3 constant magenta  4 constant green  5 constant cyan
6 constant yellow   7 constant white

2 11 thru

( Vocabulary, languages, players types)

vocabulary tron immediate  tron definitions

  \ Languages

 3 constant langs  \ number of languages
 0 constant en     \ English
 1 constant eo     \ Esperanto
 2 constant es     \ Spanish
en value lang      \ current language

3 constant max-players  \ maximum number of players
3 value pilots          \ number of configured pilots
3 value players         \ number of current players

4 constant keys/player  \ keys per player

  \ Type of players. The cfa of the control word is stored into
  \ the correspondent player variable, ready to be executed
  \ during the game. `none` is a special case, used to ignore
  \ the player in the game loop.

defer (human)  ' (human) cfa constant human
defer (robot)  ' (robot) cfa constant robot
                           0 constant none
                           0 constant dead

  \ There are two similar player fields the constants above are
  \ used with:
  \
  \ `player-pilot` holds the type of pilot, `human` or `robot`,
  \ or `none` to indicate the player is not used at all in the
  \ game.
  \
  \ `player-control` is updated at the start of every round
  \ with the contents of `player-pilot`; when a crash happens,
  \ this field is changed to `dead`, what means the player will
  \ be skipped in the game loop.

( Players data)

17 cells constant /player-data \ bytes per player data

/player-data max-players * constant /players-data
  \ /players-data buffer: players-data \ XXX OLD

  \ The players data are stored at the end of screen 7
  \ of the Forth RAM-disk:
8 disc-scr /players-data - constant players-data

  \ players-data /players-data erase \ XXX OLD

  \ Pointers to the data of every player.

players-data constant player0-data
player0-data /player-data + constant player1-data
player1-data /player-data + constant player2-data

  \ Table to access the players' data addresses.
here: player#-data player0-data , player1-data , player2-data ,

: player#-variable  ( field player "name" -- )

  \ Create a player# variable.

  \ A player# variable is a constant that points to a data
  \ field of a specific player. This way it works like an
  \ ordinary variable, but the player data can be manipulated
  \ also as a whole (e.g. store and fetch the coordinates with
  \ double numbers, for speed; erase the whole zone, etc.).

  /player-data * players-data +  \ player data address
  swap cells + constant  ;

( Player 0 data fields)

 0 0 player#-variable pilot0      \ human, robot, none
 1 0 player#-variable control0    \ human, robot, noop
 2 0 player#-variable score0      \ score
 3 0 player#-variable yc0         \ Y coordinate
 4 0 player#-variable xc0         \ X coordinate
 5 0 player#-variable yinc0       \ Y inc (-1..1)
 6 0 player#-variable xinc0       \ X inc (-1..1)
 7 0 player#-variable color0      \ ink color
 8 0 player#-variable up-k0       \ up key
 9 0 player#-variable down-k0     \ down key
10 0 player#-variable left-k0     \ left key
11 0 player#-variable right-k0    \ right key
12 0 player#-variable score-col0  \ score column
  \ Double number fields:
13 0 player#-variable start-incs0    \ start incs
15 0 player#-variable start-coords0  \ start coords

( Player 1 data fields)

 0 1 player#-variable pilot1      \ human or robot
 1 1 player#-variable control1    \ human, robot, noop
 2 1 player#-variable score1      \ score
 3 1 player#-variable yc1         \ Y coordinate
 4 1 player#-variable xc1         \ X coordinate
 5 1 player#-variable yinc1       \ Y inc (-1..1)
 6 1 player#-variable xinc1       \ X inc (-1..1)
 7 1 player#-variable color1      \ ink color
 8 1 player#-variable up-k1       \ up key
 9 1 player#-variable down-k1     \ down key
10 1 player#-variable left-k1     \ left key
11 1 player#-variable right-k1    \ right key
12 1 player#-variable score-col1  \ score column
  \ Double number fields:
13 1 player#-variable start-incs1    \ start incs
15 1 player#-variable start-coords1  \ start coords

( Player 2 data fields)

 0 2 player#-variable pilot2      \ human, robot, none
 1 2 player#-variable control2    \ human, robot, noop
 2 2 player#-variable score2      \ score
 3 2 player#-variable yc2         \ Y coordinate
 4 2 player#-variable xc2         \ X coordinate
 5 2 player#-variable yinc2       \ Y inc (-1..1)
 6 2 player#-variable xinc2       \ X inc (-1..1)
 7 2 player#-variable color2      \ ink color
 8 2 player#-variable up-k2       \ up key
 9 2 player#-variable down-k2     \ down key
10 2 player#-variable left-k2     \ left key
11 2 player#-variable right-k2    \ right key
12 2 player#-variable score-col2  \ score column
  \ Double number fields:
13 2 player#-variable start-incs2    \ start incs
15 2 player#-variable start-coords2  \ start coords

( Double or table fields )

  \ These additional definitions point to the first one of
  \ several related fields that sometimes are managed together,
  \ e.g. as a double number (coordinates and coordinates
  \ increments) or a table (keys):

up-k0 constant keys0
up-k1 constant keys1
up-k2 constant keys2
  yc0 constant coords0
  yc1 constant coords1
  yc2 constant coords2
yinc0 constant incs0
yinc1 constant incs1
yinc2 constant incs2

( Current player's data fields )

  \ Number of the current player (0..2). 
0 value player

  \ Address of the current player's data.
player0-data value player-data

: player!  ( n -- )
  \ Set the current player to _n_.
  \ n = 0..2
  dup to player  cells player#-data + @ to player-data  ;

: player-variable  ( field "name" -- )

  \ Create a player variable.

  \ A player variable returns the address of a player data
  \ field, depending on the content of `player-data`.  This way
  \ one single word can be used to manage any player.

  <builds   ( n "name" )  cells c,
  does>     ( -- a ) ( pfa )
    c@ player-data +  ;

( Current player data fields )

 0 player-variable player-pilot      \ human, robot, none
 1 player-variable player-control    \ human, robot, noop
 2 player-variable player-score      \ score
 3 player-variable player-yc         \ Y coordinate
 4 player-variable player-xc         \ X coordinate
 5 player-variable player-yinc       \ Y inc (-1..1)
 6 player-variable player-xinc       \ X inc (-1..1)
 7 player-variable player-color      \ ink color
 8 player-variable player-up-k       \ up key
 9 player-variable player-down-k     \ down key
10 player-variable player-left-k     \ left key
11 player-variable player-right-k    \ right key
12 player-variable player-score-col  \ score column
  \ Double number fields:
13 player-variable player-start-incs    \ start incs
15 player-variable player-start-coords  \ start coords

( Current player special fields )

  \ Double or table fields

  \ These additional definitions point to the first one of
  \ several related fields that sometimes are managed together,
  \ e.g. as a double number (coordinates and coordinates
  \ incrementes) or a table (keys):

5 player-variable player-incs       \ both incs
3 player-variable player-coords     \ both coordinates
8 player-variable player-keys       \ keys table

  \ Calculated fields

  \ Is the current player a human pilot?
: human?  ( -- f )  player-pilot @ human =  ;

  \ Is the current player "none"?
: none?  ( -- f )  player-pilot @ none =  ;

  \ Is the current player "someone"? (human or robot).
: someone?  ( -- f )  none? 0=  ;

  \ Is the current player alive?
: alive?  ( -- f )  player-control @ dead <>  ;

  \ Only one player alive, o no-one?
: last-one?  ( -- f )  players 2 <  ;

  \ Are all the configured players robots?
: robots-only?  ( -- f )
  true max-players 0 do  i player!
    human? if  0= leave  then
  loop  ;

( Other data-related tools)

: char-in-string?  ( c ca len -- n tf | ff )
  \ Is the char _c_ in the  string _ca len_?
  \ If so, return its position and a true flag,
  \ else return a false flag.
  over >r bounds do
    dup i c@ = if  drop i unloop r> - true exit  then
  loop  drop rdrop false  ;

: >execute  ( a n -- )
  \ Execute a cfa stored in an execution table.
  \ a = execution table
  \ n = element of the table (0..x)
  cells + @ execute  ;

  \ Remove a number of chars from a given string if `players`
  \ is 1 and the current player is a human or a robot.  This is
  \ used with the pilot help string in every language,
  \ according to the behaviour of the configuration menu, where
  \ the "none" option can not be choosen when the currently
  \ configured player is the only human or robot left.
  \ ca len = string
  \ n = chars to remove
: -none  ( ca len n -- )  players 1 = someone? and * -  ;

  \ vim: filetype=abersoftforthafera
