\ Tron
\ A game written in ZX Spectrum's Abersoft Forth.

\ tron.file_1.fsb
\ This file is the 2nd part of the source.

\ Copyright (C) 1985,2009,2015 Marcos Cruz (programandala.net)
\ Licencia/Permesilo/License: GPL 3

\ http://programandala.net/es.programa.tron.html

  \ -----------------------------------------------------------
  \ fsb directives

  \ The following '#vim' directives, processed by fsb,
  \ translate the UTF-8 chars in this source file to the ZX
  \ Spectrum UDG defined in the first file <tron.part_0.fsb>):

  \ XXX FIXME this still causes trouble with fsb.

  \ #vim %substitute@á@\=nr2char(144)@g
  \ #vim %substitute@Ĉ@\=nr2char(146)@g
  \ #vim %substitute@é@\=nr2char(148)@g
  \ #vim %substitute@ĝ@\=nr2char(150)@g
  \ #vim %substitute@í@\=nr2char(152)@g
  \ #vim %substitute@ó@\=nr2char(158)@g
  \ #vim %substitute@ú@\=nr2char(162)@g
  \ #vim %substitute@¿@\=nr2char(153)@g
  \ #vim %substitute@ŭ@\=nr2char(154)@g

( Load )

2 10 THRU
RUNT \ Load the next part of the source

( Plot and draw)

: RDRAW  ( inc-x inc-y -- )
  \ Draw a relative line (from the current plot position).
  Y-COORD C@ + SWAP X-COORD C@ + SWAP DRAW  ;

: XY>ATTRA  ( x y -- a )
  \ Convert a pixel coordinate to its attribute address.
  175 SWAP - 8 / 32 *  SWAP 8 /  + ATTRIBUTES +  ;

: COLORPLOT  ( color x y -- )
  \ Plot a pixel with the given color.
  \ There's a bug in Abersoft Forth: `PLOT` does not work
  \ when `INK` is used before. That's why this word
  \ is needed.
  2DUP PLOT XY>ATTRA C!  ;

( User Defined Graphics)

: UDG!  ( b0..b7 c -- )
  \ Store the given 8 bytes into the c UDG char
  \ c = 144..164 (144..162 on 128K models)
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  144 - 8 * UDG + 1 - DUP 8 + DO  I C!  -1 +LOOP  ;

  \ ----------------------------
  \ Spanish characters

  \ XXX TODO Esperanto letters

HEX
  08 10 38 04 3C 44 3C 00  90 UDG! \ á
  \ 04 08 3C 42 7E 42 42 00  00 UDG! \ Á
  08 10 38 44 78 40 3C 00  94 UDG! \ é
  \ 04 08 7E 40 7C 40 7E 00  00 UDG! \ É
  08 10 00 30 10 10 38 00  98 UDG! \ í
  \ 04 08 3E 08 08 08 3E 00  00 UDG! \ Í
  08 10 38 44 44 44 38 00  9E UDG! \ ó
  \ 08 10 3C 42 42 42 3C 00  00 UDG! \ Ó
  08 10 44 44 44 44 38 00  A2 UDG! \ ú
  \ 04 4A 42 42 42 42 3C 00  00 UDG! \ Ú
  \ 00 78 00 78 44 44 44 00  00 UDG! \ ñ
  \ 3C 00 62 52 4A 46 42 00  00 UDG! \ Ñ
  \ 44 00 44 44 44 44 38 00  00 UDG! \ ü
  \ 42 00 42 42 42 42 3C 00  00 UDG! \ Ü
  00 10 00 10 20 42 3C 00  99 UDG! \ ¿
DECIMAL

( Screen -- generic)

: WIPE  ( -- )
  \ Clear the screen with the default colors.
  BLACK PAPER  BLACK BORDER  WHITE INK  CLS  ;

  \ Size of the screen:
32 CONSTANT COLS
24 CONSTANT LINES

  \ Attributes address of the arena frame:
ATTRIBUTES COLS +
  CONSTANT TOP-FRAME-ATTRIBUTES
ATTRIBUTES COLS LINES 2 - * COLS - +
  CONSTANT BOTTOM-FRAME-ATTRIBUTES

( Center justified texts)

: HOME  ( -- )  0 DUP AT  ;

: CENTERED  ( len -- column )
  \ Convert a string lenght to the column required
  \ to print the string centered.
  COLS SWAP - 2 /  ;

: <AT>  ( line len -- )
  \ Put the cursor on the given line, on the column
  \ required to center a text of the given lenght.
  CENTERED AT  ;

: <LINESPACES>  ( len line -- )
  \ Type spaces centered on a given line.
  OVER <AT> SPACES  ;

: <LINETYPE>  ( ca len line -- )
  \ Type a string centered on a given line.
  OVER <AT> TYPE  ;

: <TYPE>  ( ca len -- )

  \ Type a string centered on the current line.
 
  \ Note: the line is supposed to be empty, and it will be
  \ erased at the left of the text.
  
  \ XXX TODO Get the current line and call `<LINETYPE>`instead
  \ of printing spaces.

  DUP CENTERED SPACES TYPE  ;

( Title and status bar)

: TITLE  ( -- )
  RED INK S" TRON" <TYPE> CR CR WHITE INK  ;

: SCORE. ( a color line column -- )
  \ Print the content of a score variable,
  \ with the given color, at the given position,
  \ using 3 digits.
  AT INK @ S->D <# # # # #> TYPE  ;

: .SCORE1  ( -- )  SCORE1 COLOR1 0. SCORE.  ;
: .SCORE2  ( -- )  SCORE2 COLOR2 0 29 SCORE.  ;

: STATUS  ( -- )

  \ Show the status bar at the current cursor position.

  HOME TITLE .SCORE1 .SCORE2 ;

( Arena)

RED RED PAPERY + CONSTANT FRAME-COLOR

: FRAME-BAR  ( a -- )  COLS FRAME-COLOR FILL  ;

: ARENA-BORDER  ( -- )

  \ Draw the arena visible border.

  TOP-FRAME-ATTRIBUTES FRAME-BAR  \ top part
  BOTTOM-FRAME-ATTRIBUTES FRAME-BAR  \ bottom part
  \ Left and right parts:
  BOTTOM-FRAME-ATTRIBUTES TOP-FRAME-ATTRIBUTES DO
    FRAME-COLOR DUP I C!  I [ COLS 1 - ] LITERAL + C!
  COLS +LOOP  ;

: ARENA-LIMIT  ( -- )

  \ XXX TODO Change the method:
  \ Use block graphics to draw a 4-pixel width border,
  \ and draw the bottom border with 4 lines, directly
  \ in memory.

  \ Draw the arena invisible limit.
  \ It's used to detect crashes.
  7 7 PLOT 0 153 RDRAW 241 0 RDRAW 0 -153 RDRAW -241 0 RDRAW  ;
  \ XXX OLD -- This draws the pixel line below X coordinate 0,
  \ but it doesn't work because it can not be detected by
  \ `PLOT`:
  \ 20673 [ COLS 2 - ] LITERAL 255 FILL

: FRAME  ( -- )  BLACK INK ARENA-LIMIT ARENA-BORDER  ;

: ARENA  ( -- )
  \ Draw the arena.
  WIPE FRAME STATUS  ;

  \ vim: filetype=abersoftforth:fileencoding=utf-8
